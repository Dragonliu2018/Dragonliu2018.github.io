{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://dragonliu2018.github.io","root":"/"},"pages":[{"title":"友情链接","date":"2019-09-13T08:58:45.000Z","updated":"2025-09-13T14:32:57.218Z","comments":true,"path":"link/index.html","permalink":"https://dragonliu2018.github.io/link/index.html","excerpt":"","text":""},{"title":"看板","date":"2025-09-13T14:32:57.212Z","updated":"2025-09-13T14:32:57.212Z","comments":false,"path":"about/index.html","permalink":"https://dragonliu2018.github.io/about/index.html","excerpt":"","text":"联系方式：dragonliu2018@gmail.com 1 分类 CTF Web Pwn Reverse Crypto Misc WP 恶意代码 环境与工具 网络安全 漏洞 安全阅读 面试"},{"title":"光影流年","date":"2019-09-13T08:56:36.000Z","updated":"2025-09-13T14:32:57.216Z","comments":true,"path":"gallery/index.html","permalink":"https://dragonliu2018.github.io/gallery/index.html","excerpt":"","text":""},{"title":"分类","date":"2025-09-13T14:32:57.214Z","updated":"2025-09-13T14:32:57.214Z","comments":false,"path":"categories/index.html","permalink":"https://dragonliu2018.github.io/categories/index.html","excerpt":"","text":""},{"title":"那些年，听过的音乐","date":"2025-09-13T14:32:57.220Z","updated":"2025-09-13T14:32:57.220Z","comments":true,"path":"music/index.html","permalink":"https://dragonliu2018.github.io/music/index.html","excerpt":"","text":"&#123;% meting &quot;7429975963&quot; &quot;tencent&quot; &quot;playlist&quot; %&#125;&#123;% douban music 30121600 %&#125;"},{"title":"标签","date":"2025-09-13T14:32:57.223Z","updated":"2025-09-13T14:32:57.223Z","comments":false,"path":"tags/index.html","permalink":"https://dragonliu2018.github.io/tags/index.html","excerpt":"","text":""},{"title":"主题更新日志","date":"2019-09-13T08:58:45.000Z","updated":"2025-09-13T14:32:57.225Z","comments":true,"path":"theme/index.html","permalink":"https://dragonliu2018.github.io/theme/index.html","excerpt":"","text":"本站当前主题使用的是Hexo Butterfly TODO 博客相册页面 2021 年 02 月 2月23日： 添加菜单-主题 更改首页图片：点击查看 2月26日 解决博客加密文章本地测试通过，提交到GitHub后未通过问题，访问 https://dragonliu.tk 即可。参考：hexo-blog-encrypt 在 http 环境下无法使用的原因分析 文章加密部分使用 sweetalert 来美化错误提示。参考"},{"title":"Repositories","date":"2025-09-13T14:32:57.222Z","updated":"2025-09-13T14:32:57.222Z","comments":false,"path":"repository/index.html","permalink":"https://dragonliu2018.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"[Databend][pr] pivot 支持 subquery","slug":"Databend-pr-pivot-支持-subquery","date":"2025-09-14T09:45:42.000Z","updated":"2025-09-14T13:04:44.992Z","comments":true,"path":"2025/09/14/Databend-pr-pivot-支持-subquery/","permalink":"https://dragonliu2018.github.io/2025/09/14/Databend-pr-pivot-%E6%94%AF%E6%8C%81-subquery/","excerpt":"","text":"1 任务背景 Issue：https://github.com/databendlabs/databend/issues/16556 **PR：**https://github.com/databendlabs/databend/pull/16631 1.1 任务介绍 目前 databend 中的 pivot 和 unpivot 不支持 FROM/IN + subquery。→ 文档链接 要求实现类似于 snowflake 的语法，也就是让 pivot 支持 FROM/IN + subquery，unpivot 支持 FROM + subquery。→ 文档链接 databend PIVOT 语法 SELECT ...FROM ... PIVOT ( &lt;aggregate_function&gt; ( &lt;pivot_column&gt; ) FOR &lt;value_column&gt; IN ( &lt;pivot_value_1&gt; [ , &lt;pivot_value_2&gt; ... ] ) )[ ... ] &lt;aggregate_function&gt;：用于组合来自pivot_column的分组值的聚合函数。 &lt;pivot_column&gt;：将使用指定的&lt;aggregate_function&gt;进行聚合的列。 &lt;value_column&gt;：其唯一值将在旋转结果集中成为新列的列。 &lt;pivot_value_N&gt;：来自&lt;value_column&gt;的唯一值，将在旋转结果集中成为新列。 databend UNPIVOT 语法 SELECT ...FROM ... UNPIVOT ( &lt;value_column&gt; FOR &lt;name_column&gt; IN ( &lt;column_list&gt; ) )[ ... ] &lt;value_column&gt;：将存储从 &lt;column_list&gt; 中列出的列中提取的值的列。 &lt;name_column&gt;：将存储从中提取值的列的名称的列。 &lt;column_list&gt;：要取消透视的列的列表，用逗号分隔。 snowflake PIVOT 语法 123456789101112SELECT ...FROM ... PIVOT ( &lt;aggregate_function&gt; ( &lt;pivot_column&gt; ) FOR &lt;value_column&gt; IN ( &lt;pivot_value_1&gt; [ , &lt;pivot_value_2&gt; ... ] | ANY [ ORDER BY ... ] | &lt;subquery&gt; ) [ DEFAULT ON NULL (&lt;value&gt;) ] )[ ... ] snowflake UNPIVOT 语法 SELECT ...FROM ... UNPIVOT [ &#123; INCLUDE | EXCLUDE &#125; NULLS ] ( &lt;value_column&gt; FOR &lt;name_column&gt; IN ( &lt;column_list&gt; ) )[ ... ] 1.2 介绍 pivot &amp; unpivot 1.2.1 pivot（透视，一列中的属性值转成多个对应属性） https://docs.databend.com/sql/sql-commands/query-syntax/query-pivot PIVOT操作通过旋转表格并基于指定列聚合结果来转换表格，这是一个对于总结和分析大量数据以更可读格式显示非常有用的操作。 databend PIVOT 语法 SELECT ...FROM ... PIVOT ( &lt;aggregate_function&gt; ( &lt;pivot_column&gt; ) FOR &lt;value_column&gt; IN ( &lt;pivot_value_1&gt; [ , &lt;pivot_value_2&gt; ... ] ) )[ ... ] &lt;aggregate_function&gt;：用于组合来自pivot_column的分组值的聚合函数。 &lt;pivot_column&gt;：将使用指定的&lt;aggregate_function&gt;进行聚合的列。 &lt;value_column&gt;：其唯一值将在旋转结果集中成为新列的列。 &lt;pivot_value_N&gt;：来自&lt;value_column&gt;的唯一值，将在旋转结果集中成为新列。 假设我们有一个名为 monthly_sales 的表，其中包含不同员工在不同月份的销售数据。我们可以使用PIVOT操作来总结数据并计算每个员工在每个月的总销售额。 创建和插入数据 12345678910111213141516171819202122232425-- 创建monthly_sales表CREATE TABLE monthly_sales( empid INT, amount INT, month VARCHAR);-- 插入销售数据INSERT INTO monthly_sales VALUES (1, 10000, &#x27;JAN&#x27;), (1, 400, &#x27;JAN&#x27;), (2, 4500, &#x27;JAN&#x27;), (2, 35000, &#x27;JAN&#x27;), (1, 5000, &#x27;FEB&#x27;), (1, 3000, &#x27;FEB&#x27;), (2, 200, &#x27;FEB&#x27;), (2, 90500, &#x27;FEB&#x27;), (1, 6000, &#x27;MAR&#x27;), (1, 5000, &#x27;MAR&#x27;), (2, 2500, &#x27;MAR&#x27;), (2, 9500, &#x27;MAR&#x27;), (1, 8000, &#x27;APR&#x27;), (1, 10000, &#x27;APR&#x27;), (2, 800, &#x27;APR&#x27;), (2, 4500, &#x27;APR&#x27;); 使用 PIVOT 现在，我们可以使用PIVOT操作来计算每个员工在每个月的总销售额。我们将使用SUM聚合函数来计算总销售额，MONTH 列将被旋转以为每个月创建新列。 SELECT *FROM monthly_salesPIVOT(SUM(amount) FOR MONTH IN (&#x27;JAN&#x27;, &#x27;FEB&#x27;, &#x27;MAR&#x27;, &#x27;APR&#x27;))ORDER BY EMPID; 输出： +-------+-------+-------+-------+-------+| empid | jan | feb | mar | apr |+-------+-------+-------+-------+-------+| 1 | 10400 | 8000 | 11000 | 18000 || 2 | 39500 | 90700 | 12000 | 5300 |+-------+-------+-------+-------+-------+ 1.2.2 unpivot（取消透视，多个属性转成一列中对应的属性值） https://docs.databend.com/sql/sql-commands/query-syntax/query-unpivot UNPIVOT 操作通过将列转换为行来旋转表。它是一个关系操作符，接受两列（来自表或子查询），以及列的列表，并为列表中指定的每列生成一行。在查询中，它在 FROM 子句中指定，位于表名或子查询之后。 databend UNPIVOT 语法 SELECT ...FROM ... UNPIVOT ( &lt;value_column&gt; FOR &lt;name_column&gt; IN ( &lt;column_list&gt; ) )[ ... ] &lt;value_column&gt;：将存储从 &lt;column_list&gt; 中列出的列中提取的值的列。 &lt;name_column&gt;：将存储从中提取值的列的名称的列。 &lt;column_list&gt;：要取消透视的列的列表，用逗号分隔。 让我们取消透视个别月份列，以返回每位员工每月的单一销售值： 创建和插入数据 12345678910111213-- 创建 unpivoted_monthly_sales 表CREATE TABLE unpivoted_monthly_sales( empid INT, jan INT, feb INT, mar INT, apr INT);-- 插入销售数据INSERT INTO unpivoted_monthly_sales VALUES (1, 10400, 8000, 11000, 18000), (2, 39500, 90700, 12000, 5300); 使用 UNPIVOT SELECT *FROM unpivoted_monthly_sales UNPIVOT (amount FOR month IN (jan, feb, mar, apr)); 输出： 123456789101112+-------+-------+--------+| empid | month | amount |+-------+-------+--------+| 1 | jan | 10400 || 1 | feb | 8000 || 1 | mar | 11000 || 1 | apr | 18000 || 2 | jan | 39500 || 2 | feb | 90700 || 2 | mar | 12000 || 2 | apr | 5300 |+-------+-------+--------+ 2 设计参考（竞品分析） 3 思路与实现 3.1 思路 实现 from + subquery 较为简单，在 TableReference::Subquery 加上 pivot 和 unpivot 字段，修改 parser 及其他相关地方。 123456789101112let subquery = map( rule! &#123; LATERAL? ~ &quot;(&quot; ~ #query ~ &quot;)&quot; ~ #table_alias? ~ #pivot? ~ #unpivot? &#125;, |(lateral, _, subquery, _, alias, pivot, unpivot)| TableReferenceElement::Subquery &#123; lateral: lateral.is_some(), subquery: Box::new(subquery), alias, pivot: pivot.map(Box::new), unpivot: unpivot.map(Box::new), &#125;,); 实现 in + subquery 相对复杂，因为在 binder 的时候必须知道 column 的 name 才能生成逻辑计划，所以只能先执行一下这个 subquery ，然后把返回值当作 values 处理；但是执行 query/plan 是在 service 模块下，binder 是在 sql 模块，存在循环调用的问题。→ 解决循环依赖问题 解决思路有三种： 【思路-1】在 pivot_rewrite 阶段（binder）执行 Subquery 得到答案，参考 QuerySampleExecutor 写个回调函数在 binder 里面调一下 service 的函数执行。 Pivot 结构体新添 Subquery 字段（Query），用于存储 in + subquery 中的 subquery； Pivot 123456789101112131415161718// 原版pub struct Pivot &#123; pub aggregate: Expr, pub value_column: Identifier, pub values: Vec&lt;Expr&gt;,&#125;// 修改后pub enum PivotValues &#123; ColumnValues(Vec&lt;Expr&gt;), Subquery(Box&lt;Query&gt;),&#125;pub struct Pivot &#123; pub aggregate: Expr, pub value_column: Identifier, pub values: PivotValues,&#125; 在 rewrite_pivot 函数中对 Subquery 进行 parser + rewrite + opt + exec 等操作，并将结果存在原来的 values 字段，后续操作一致。 执行 query 的回调函数目前有基于 PhysicalPlan 的，一种方案是基于该函数进行操作；另一种方案是新添基于 Query String 执行的回调函数。 【思路-2】在发现 subquery 的时候返回，在 service 里面执行之后重写 sql，然后再次执行。 【思路-3】现在的 plan_sql 函数里面会执行 parser 并生成 plan，可以把这个函数拆成两个： 第一个函数执行 parser，生成 stmt，同时进行一些 rewrite，如果这时发现有 subquery 的话，就先执行一下，然后 rewrite。 第二个函数传入 rewrite 之后的 stmt，生成 plan。 本着尽可能少的改动当前代码结构的原则，选择**【思路-1】**进行实现。 3.2 review 相关修改 【review-1】避免不必要的 clone 123456789101112131415161718192021// 原版let value = columns[0].to_column(block.num_rows()); // 修改for row in 0..block.num_rows() &#123; match columns[0].value.index(row).unwrap() &#123; ScalarRef::String(s) =&gt; &#123; let literal = Expr::Literal &#123; span, value: Literal::String(s.to_string()), &#125;; values.push(literal); &#125; _ =&gt; &#123; return Err(ErrorCode::SemanticError( &quot;The subquery of `pivot in` must return a string type&quot;, ) .set_span(span)); &#125; &#125;&#125; 【review-2】针对于 subquery 返回的每个 String 不需要设置 span，使用 subquery 的 span 即可。 【review-3】使用 block.num_columns() 计算 column 的数量。 // 原版let columns = block.columns();if columns.len() != 1 &#123; // ...&#125;// 修改后if block.num_columns() != 1 &#123; // ...&#125; 【review-4】将 sample_executor 和 subquery_executor 合并成一个 query_executor，实现不同的函数用来做区分。 【review-5】对返回的 ErrorCode 设置 span。→ span 不使用 span： return Err(ErrorCode::SemanticError( &quot;The subquery of `pivot in` must return one column&quot;,)); MySQL [dev]&gt; SELECT * FROM (select * from monthly_sales) PIVOT(SUM(amount) FOR MONTH IN (select distinct month, month from monthly_sales)) ORDER BY EMPID;ERROR 1105 (HY000): SemanticError. Code: 1065, Text = The subquery of `pivot in` must return one column. 使用 span： return Err(ErrorCode::SemanticError( &quot;The subquery of `pivot in` must return one column&quot;,).set_span(span)); MySQL [dev]&gt; SELECT * FROM (select * from monthly_sales) PIVOT(SUM(amount) FOR MONTH IN (select distinct empid from monthly_sales)) ORDER BY EMPID;ERROR 1105 (HY000): SemanticError. Code: 1065, Text = error: --&gt; SQL:1:78 |1 | SELECT * FROM (select * from monthly_sales) PIVOT(SUM(amount) FOR MONTH IN (select distinct empid from monthly_sales)) ORDER BY EMPID | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ The subquery of `pivot in` must return a string type. 3.3 bugs 【bug-1】因为需要两次用到 pivot 变量，所以会报 error: use of moved value 的错误。→ error: use of moved value 把 pivot 和 unpivot 挪出去，改成两个单独的函数。 【bug-2】rewrite_pivot 是非 async 函数，但是 subquery_executor.execute_query_with_sql_string 是 async 函数，rewrite_pivot 中需要调用 subquery_executor.execute_query_with_sql_string。所以会报错：await is only allowed inside async functions and blocks。→ 在非 async 函数里调用 async 函数 databend_common_base::runtime::block_on 4 测试 4.1 功能测试 与 snowflake 语法保持一致： pivot 支持三种 subquery，from + subquery、in + subquery、from + subquery + in + subquery。 unpivot 只支持 from + subquery 一种。 4.1.1 手动测试 测试 Pivot Create the monthly_sales table CREATE TABLE monthly_sales( empid INT, amount INT, month VARCHAR); Insert sales data 1234567891011121314151617INSERT INTO monthly_sales VALUES (1, 10000, &#x27;JAN&#x27;), (1, 400, &#x27;JAN&#x27;), (2, 4500, &#x27;JAN&#x27;), (2, 35000, &#x27;JAN&#x27;), (1, 5000, &#x27;FEB&#x27;), (1, 3000, &#x27;FEB&#x27;), (2, 200, &#x27;FEB&#x27;), (2, 90500, &#x27;FEB&#x27;), (1, 6000, &#x27;MAR&#x27;), (1, 5000, &#x27;MAR&#x27;), (2, 2500, &#x27;MAR&#x27;), (2, 9500, &#x27;MAR&#x27;), (1, 8000, &#x27;APR&#x27;), (1, 10000, &#x27;APR&#x27;), (2, 800, &#x27;APR&#x27;), (2, 4500, &#x27;APR&#x27;); Pivot（原版） SELECT * FROM monthly_salesPIVOT(SUM(amount) FOR MONTH IN (&#x27;JAN&#x27;, &#x27;FEB&#x27;, &#x27;MAR&#x27;, &#x27;APR&#x27;))ORDER BY EMPID; from + subquery SELECT *FROM (select * from monthly_sales)PIVOT(SUM(amount) FOR MONTH IN (&#x27;JAN&#x27;, &#x27;FEB&#x27;, &#x27;MAR&#x27;, &#x27;APR&#x27;))ORDER BY EMPID; in + subquery SELECT * FROM monthly_salesPIVOT(SUM(amount) FOR MONTH IN (select distinct month from monthly_sales))ORDER BY EMPID; from + in + subquery SELECT * FROM (select * from monthly_sales)PIVOT(SUM(amount) FOR MONTH IN (select distinct month from monthly_sales))ORDER BY EMPID; Answer +-------+-------+-------+-------+-------+| empid | jan | feb | mar | apr |+-------+-------+-------+-------+-------+| 1 | 10400 | 8000 | 11000 | 18000 || 2 | 39500 | 90700 | 12000 | 5300 |+-------+-------+-------+-------+-------+ 测试 Unpivot Create the unpivoted_monthly_sales table CREATE TABLE unpivoted_monthly_sales( empid INT, jan INT, feb INT, mar INT, apr INT); Insert sales data INSERT INTO unpivoted_monthly_sales VALUES (1, 10400, 8000, 11000, 18000), (2, 39500, 90700, 12000, 5300); unpivot（原版） SELECT *FROM unpivoted_monthly_sales UNPIVOT (amount FOR month IN (jan, feb, mar, apr)); from + subquery SELECT * FROM (SELECT * FROM monthly_sales_1) UNPIVOT(sales FOR month IN (jan, feb, mar, april)) ORDER BY empid Answer 123456789101112+-------+-------+--------+| empid | month | amount |+-------+-------+--------+| 1 | jan | 10400 || 1 | feb | 8000 || 1 | mar | 11000 || 1 | apr | 18000 || 2 | jan | 39500 || 2 | feb | 90700 || 2 | mar | 12000 || 2 | apr | 5300 |+-------+-------+--------+ 4.1.2 单元测试（ast 相关） make unit-test parser 改了会导致之前的测试失败，修复下面两个文件： src/query/ast/tests/it/testdata/stmt.txt src/query/ast/tests/it/testdata/query.txt 另外在 test_query 函数加上一个 pivot &amp; unpivot 带 subquery 的测试用例，相关文件：src/query/ast/tests/it/parser.rs。 4.1.3 逻辑测试（sql 执行结果） make sqllogic-test 为了加快测试速度，可以指定目录进行执行，甚至可以修改文件名使其在当前目录先执行： ./target/debug/databend-sqllogictests --handlers mysql --run_dir query 添加 pivot &amp; unpivot 相关 sql 查询，相关文件： tests/sqllogictests/suites/query/pivot.test tests/sqllogictests/suites/query/unpivot.test 4.2 性能测试 5 难点 6 TODO X 参考 https://docs.snowflake.com/en/sql-reference/constructs/pivot https://docs.snowflake.com/en/sql-reference/constructs/unpivot https://docs.databend.com/sql/sql-commands/query-syntax/query-pivot https://docs.databend.com/sql/sql-commands/query-syntax/query-unpivot","categories":[{"name":"DB","slug":"DB","permalink":"https://dragonliu2018.github.io/categories/DB/"},{"name":"Databend","slug":"DB/Databend","permalink":"https://dragonliu2018.github.io/categories/DB/Databend/"},{"name":"pr","slug":"DB/Databend/pr","permalink":"https://dragonliu2018.github.io/categories/DB/Databend/pr/"},{"name":"执行器","slug":"DB/Databend/执行器","permalink":"https://dragonliu2018.github.io/categories/DB/Databend/%E6%89%A7%E8%A1%8C%E5%99%A8/"},{"name":"表达式","slug":"DB/Databend/执行器/表达式","permalink":"https://dragonliu2018.github.io/categories/DB/Databend/%E6%89%A7%E8%A1%8C%E5%99%A8/%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"执行器","slug":"DB/执行器","permalink":"https://dragonliu2018.github.io/categories/DB/%E6%89%A7%E8%A1%8C%E5%99%A8/"},{"name":"表达式","slug":"DB/执行器/表达式","permalink":"https://dragonliu2018.github.io/categories/DB/%E6%89%A7%E8%A1%8C%E5%99%A8/%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}],"tags":[{"name":"pr","slug":"pr","permalink":"https://dragonliu2018.github.io/tags/pr/"}]},{"title":"[Doris][pr] Implement format methods for Status","slug":"Doris-pr-Implement-format-methods-for-Status","date":"2025-09-14T09:26:44.000Z","updated":"2025-09-14T12:49:48.948Z","comments":true,"path":"2025/09/14/Doris-pr-Implement-format-methods-for-Status/","permalink":"https://dragonliu2018.github.io/2025/09/14/Doris-pr-Implement-format-methods-for-Status/","excerpt":"","text":"1 issue 介绍 当前 Status 类型进行 format 时，需要调用 to_string 函数： fmt::format(&quot;&#123;&#125;&quot;, status.to_string()); 想要的效果是只需要传入 Status 类型即可： fmt::format(&quot;&#123;&#125;&quot;, status); 2 实现 2.1 解析 fmt 库提供了一个类模板 fmt::formatter，通过模板特化为 Status 类型提供适当的格式化方式。 然后实现 parse 和 format 函数即可： parse 函数负责解析格式字符串。在通常情况下，用户可能不需要提供自己的 parse 函数，而可以使用 fmt 默认提供的版本，该版本简单地返回解析上下文的开始迭代器。 format 函数是用户必须提供的关键成员函数。它定义了如何将自定义类型格式化为字符串。 2.2 功能代码 👉 **参考：**https://wgml.pl/blog/formatting-user-defined-types-fmt.html 12345678910111213// specify formatter for Statustemplate &lt;&gt;struct fmt::formatter&lt;doris::Status&gt; &#123; template &lt;typename ParseContext&gt; constexpr auto parse(ParseContext&amp; ctx) &#123; return ctx.begin(); &#125; template &lt;typename FormatContext&gt; auto format(doris::Status const&amp; status, FormatContext&amp; ctx) &#123; return fmt::format_to(ctx.out(), &quot;&#123;&#125;&quot;, status.to_string()); &#125;&#125;; 2.3 测试代码 实现完成后，编写测试样例，这里需要注意覆盖率。 reviewer 提出的建议是： please add 3 tests：1. status == ok2. status == error &amp;&amp; has stacktrace3. status == error &amp;&amp; do not have stacktrace 3 问题 3.1 ld: symbol(s) not found for architecture x86_64 在本地 macos 上尝试写了个测试程序，但是发生下面的报错： ➜ test-reset git:(main) ✗ g++ test.cpp -std=c++20 -o testUndefined symbols for architecture x86_64: &quot;void fmt::v10::detail::vformat_to&lt;char&gt;(fmt::v10::detail::buffer&lt;char&gt;&amp;, fmt::v10::basic_string_view&lt;char&gt;, fmt::v10::detail::vformat_args&lt;char&gt;::type, fmt::v10::detail::locale_ref)&quot;, referenced from: fmt::v10::appender fmt::v10::vformat_to&lt;fmt::v10::appender, 0&gt;(fmt::v10::appender, fmt::v10::basic_string_view&lt;char&gt;, fmt::v10::basic_format_args&lt;fmt::v10::basic_format_context&lt;fmt::v10::appender, char&gt; &gt;) in test-878b3f.o &quot;fmt::v10::detail::assert_fail(char const*, int, char const*)&quot;, referenced from: std::__1::make_unsigned&lt;long&gt;::type fmt::v10::detail::to_unsigned&lt;long&gt;(long) in test-878b3f.o &quot;fmt::v10::vprint(fmt::v10::basic_string_view&lt;char&gt;, fmt::v10::basic_format_args&lt;fmt::v10::basic_format_context&lt;fmt::v10::appender, char&gt; &gt;)&quot;, referenced from: _main in test-878b3f.old: symbol(s) not found for architecture x86_64clang: error: linker command failed with exit code 1 (use -v to see invocation) 解决：原因是未链接 fmt 库文件 g++ test.cpp -std=c++20 -o test -lfmt 参考：https://stackoverflow.com/questions/56608684/how-to-use-the-fmt-library-without-getting-undefined-symbols-for-architecture-x 3.2 fmt::formatter 模板特化代码不能在 doris 的 namespace 开始将特化代码放在了 doris namespace 中，发生了下面的报错： Class template specialization of &#x27;formatter&#x27; not in a namespace enclosing &#x27;v8&#x27; is a Microsoft extension clang(-Wmicrosoft-template)[core.h(707, 8): ] Explicitly specialized declaration is here 解决： namespace doris &#123;// doris code&#125; // end doris_namespace// define formatter here **参考：**https://github.com/fmtlib/fmt/issues/2767","categories":[{"name":"Doris","slug":"Doris","permalink":"https://dragonliu2018.github.io/categories/Doris/"},{"name":"pr","slug":"Doris/pr","permalink":"https://dragonliu2018.github.io/categories/Doris/pr/"}],"tags":[{"name":"pr","slug":"pr","permalink":"https://dragonliu2018.github.io/tags/pr/"}]},{"title":"[Tool] Hexo 使用教程","slug":"Tool-Hexo-使用教程","date":"2025-09-13T15:37:08.000Z","updated":"2025-09-14T16:48:24.062Z","comments":true,"path":"2025/09/13/Tool-Hexo-使用教程/","permalink":"https://dragonliu2018.github.io/2025/09/13/Tool-Hexo-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","excerpt":"","text":"环境准备 ➜ nvm --version0.39.1➜ node -vv24.8.0➜ npm -v11.6.0# 安装 Hexonpm install -g hexo-cli 本地运行 Hexo 初始化 hexo，生成 hexo-blog 目录 hexo init hexo-blog 进入 hexo-blog 目录，下载 pure 主题和 source 文章 cd hexo-bloggit clone https://github.com/Dragonliu2018/hexo-theme-pure.git themes/puregit clone https://github.com/Dragonliu2018/hexo-source.git source 配置 pure，ref link npm install hexo-wordcount --savenpm install hexo-generator-json-content --savenpm install hexo-generator-feed --savenpm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --savenpm install hexo-neat --savenpm install hexo-baidu-url-submit --savenpm install hexo-translate-title --savenpm un hexo-renderer-marked --savenpm i hexo-renderer-markdown-it-plus --save 修改 _config.yml 1234567891011121314151617# 页面中分类等导航词的语言- language: en+ language: zh-CN# 搜索界面的分类部分拼接 url- url: https://example.com+ url: https://dragonliu2018.github.io# 设置主题- theme: + theme: pure# 设置部署deploy: type: git repo: https://github.com/dragonliu2018/dragonliu2018.github.io.git branch: master 运行 hexo hexo ghexo s 部署 Github 参考：https://hexo.io/docs/one-command-deployment 安装 hexo-deployer-git npm install hexo-deployer-git --save 修改项目根目录 blog 下的 _config.yml deploy: type: git repo: https://github.com/dragonliu2018/dragonliu2018.github.io.git branch: master 部署 hexo g 常用命令 hexo cleanhexo ghexo shexo d","categories":[{"name":"Tool","slug":"Tool","permalink":"https://dragonliu2018.github.io/categories/Tool/"},{"name":"Hexo","slug":"Tool/Hexo","permalink":"https://dragonliu2018.github.io/categories/Tool/Hexo/"}],"tags":[]}],"categories":[{"name":"DB","slug":"DB","permalink":"https://dragonliu2018.github.io/categories/DB/"},{"name":"Databend","slug":"DB/Databend","permalink":"https://dragonliu2018.github.io/categories/DB/Databend/"},{"name":"pr","slug":"DB/Databend/pr","permalink":"https://dragonliu2018.github.io/categories/DB/Databend/pr/"},{"name":"执行器","slug":"DB/Databend/执行器","permalink":"https://dragonliu2018.github.io/categories/DB/Databend/%E6%89%A7%E8%A1%8C%E5%99%A8/"},{"name":"表达式","slug":"DB/Databend/执行器/表达式","permalink":"https://dragonliu2018.github.io/categories/DB/Databend/%E6%89%A7%E8%A1%8C%E5%99%A8/%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"执行器","slug":"DB/执行器","permalink":"https://dragonliu2018.github.io/categories/DB/%E6%89%A7%E8%A1%8C%E5%99%A8/"},{"name":"表达式","slug":"DB/执行器/表达式","permalink":"https://dragonliu2018.github.io/categories/DB/%E6%89%A7%E8%A1%8C%E5%99%A8/%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"Doris","slug":"Doris","permalink":"https://dragonliu2018.github.io/categories/Doris/"},{"name":"pr","slug":"Doris/pr","permalink":"https://dragonliu2018.github.io/categories/Doris/pr/"},{"name":"Tool","slug":"Tool","permalink":"https://dragonliu2018.github.io/categories/Tool/"},{"name":"Hexo","slug":"Tool/Hexo","permalink":"https://dragonliu2018.github.io/categories/Tool/Hexo/"}],"tags":[{"name":"pr","slug":"pr","permalink":"https://dragonliu2018.github.io/tags/pr/"}]}