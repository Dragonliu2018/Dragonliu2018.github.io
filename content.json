{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://dragonliu2018.github.io","root":"/"},"pages":[{"title":"看板","date":"2025-09-25T15:50:35.151Z","updated":"2025-09-13T14:32:57.212Z","comments":false,"path":"about/index.html","permalink":"https://dragonliu2018.github.io/about/index.html","excerpt":"","text":"联系方式：dragonliu2018@gmail.com 1 分类 CTF Web Pwn Reverse Crypto Misc WP 恶意代码 环境与工具 网络安全 漏洞 安全阅读 面试"},{"title":"分类","date":"2025-09-25T15:50:35.160Z","updated":"2025-09-13T14:32:57.214Z","comments":false,"path":"categories/index.html","permalink":"https://dragonliu2018.github.io/categories/index.html","excerpt":"","text":""},{"title":"光影流年","date":"2019-09-13T08:56:36.000Z","updated":"2025-09-13T14:32:57.216Z","comments":true,"path":"gallery/index.html","permalink":"https://dragonliu2018.github.io/gallery/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-09-13T08:58:45.000Z","updated":"2025-09-13T14:32:57.218Z","comments":true,"path":"link/index.html","permalink":"https://dragonliu2018.github.io/link/index.html","excerpt":"","text":""},{"title":"那些年，听过的音乐","date":"2025-09-25T15:50:35.178Z","updated":"2025-09-13T14:32:57.220Z","comments":true,"path":"music/index.html","permalink":"https://dragonliu2018.github.io/music/index.html","excerpt":"","text":"&#123;% meting &quot;7429975963&quot; &quot;tencent&quot; &quot;playlist&quot; %&#125;&#123;% douban music 30121600 %&#125;"},{"title":"导航","date":"2025-09-25T15:50:35.224Z","updated":"2025-09-24T16:04:17.872Z","comments":false,"path":"navigation/index.html","permalink":"https://dragonliu2018.github.io/navigation/index.html","excerpt":"","text":"DB doris 1 2 databend 1 2 Tool Hexo 1 2 开源 项目1 1 2"},{"title":"Repositories","date":"2025-09-25T15:50:35.187Z","updated":"2025-09-13T14:32:57.222Z","comments":false,"path":"repository/index.html","permalink":"https://dragonliu2018.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2025-09-25T15:50:35.187Z","updated":"2025-09-13T14:32:57.223Z","comments":false,"path":"tags/index.html","permalink":"https://dragonliu2018.github.io/tags/index.html","excerpt":"","text":""},{"title":"主题更新日志","date":"2019-09-13T08:58:45.000Z","updated":"2025-09-13T14:32:57.225Z","comments":true,"path":"theme/index.html","permalink":"https://dragonliu2018.github.io/theme/index.html","excerpt":"","text":"本站当前主题使用的是Hexo Butterfly TODO 博客相册页面 2021 年 02 月 2月23日： 添加菜单-主题 更改首页图片：点击查看 2月26日 解决博客加密文章本地测试通过，提交到GitHub后未通过问题，访问 https://dragonliu.tk 即可。参考：hexo-blog-encrypt 在 http 环境下无法使用的原因分析 文章加密部分使用 sweetalert 来美化错误提示。参考"}],"posts":[{"title":"[PL][C++] 性能优化汇总","slug":"PL-C-性能优化汇总","date":"2025-09-25T16:06:51.000Z","updated":"2025-09-25T16:20:12.162Z","comments":true,"path":"2025/09/26/PL-C-性能优化汇总/","permalink":"https://dragonliu2018.github.io/2025/09/26/PL-C-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%B1%87%E6%80%BB/","excerpt":"","text":"常用技巧 避免构造不必要的对象，例如 std::string 函数返回值为常量字符串时，且需要 std::string_view 类型；函数返回值类型可以设为 std::string_view，如果设为 std::string，会有多余的拷贝。 分支预测 &amp; unlikely ref：https://www.zhihu.com/question/639443238 避免反复构造和析构 vector 【热点】 问题来源于 YMatrix 实习，下面的 vector 声明在了 for 循环内部，每次遍历都会进行构造和析构，成本较大。 for (std::size_t i = 0; i &lt; times; ++i) &#123; std::vector&lt;std::uint32_t&gt; idx_chain; func(idx_chain);&#125; 【优化】 可以将 vector 声明位置提到 for 循环外部，每次遍历对 vector 进行 clear 即可 std::vector&lt;std::uint32_t&gt; idx_chain;for (std::size_t i = 0; i &lt; times; ++i) &#123; idx_chain.clear(); func(idx_chain);&#125; vector 使用 reserve 避免重复内存申请与数据复制 场景介绍 当使用 vector 时，如果已知需要多少元素的空间，则使用 reserve 函数预先分配足够的内存空间，减少动态内存分配和元素复制的次数。这使得插入操作更加高效，尤其是在处理大量数据时，性能优势更加明显。 代码验证 【链接】https://quick-bench.com/q/ctDLCeIqzoycLX9KUuBajAapaUA 代码 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int SIZE = 10000;int vector_push_back_one_by_one() &#123; std::vector&lt;std::string&gt; str_vec; for (int i = 0; i &lt; SIZE; i++) &#123; str_vec.push_back(std::to_string(i)); &#125; return 0;&#125;int vector_push_back_reserve() &#123; std::vector&lt;std::string&gt; str_vec; str_vec.reserve(SIZE); for (int i = 0; i &lt; SIZE; i++) &#123; str_vec.push_back(std::to_string(i)); &#125; return 0;&#125;static void PushOneByOne(benchmark::State&amp; state) &#123; // Code inside this loop is measured repeatedly for (auto _ : state) &#123; auto ret = vector_push_back_one_by_one(); // Make sure the variable is not optimized away by compiler benchmark::DoNotOptimize(ret); &#125;&#125;// Register the function as a benchmarkBENCHMARK(PushOneByOne);static void PushReserve(benchmark::State&amp; state) &#123; // Code before the loop is not measured for (auto _ : state) &#123; auto ret = vector_push_back_reserve(); // Make sure the variable is not optimized away by compiler benchmark::DoNotOptimize(ret); &#125;&#125;BENCHMARK(PushReserve); GPT 现象解释 vector_push_back_reserve 函数比 vector_push_back_one_by_one 函数高效的原因主要在于内存分配策略的不同。 vector_push_back_one_by_one 函数 动态内存分配：std::vector 的 push_back 方法会在容器容量不足时，自动分配新的内存来存储更多的元素。每次分配的内存大小通常是当前容量的两倍左右（具体策略因标准库实现而异）。例如，初始容量可能为 0，第一次调用 push_back 时分配一定大小的内存（如 16 个元素的空间），当插入第 17 个元素时，会重新分配内存（如 32 个元素的空间），并将原有元素复制到新的内存空间中，然后释放旧的内存空间。 多次内存分配和复制：在插入大量元素时，这种动态内存分配会导致多次内存分配和复制操作。每次重新分配内存时，都需要将已有的元素复制到新的内存空间中，这会消耗大量的时间和计算资源。随着元素数量的增加，这种开销会逐渐累积，导致整体性能下降。 vector_push_back_reserve 函数 预先分配内存：std::vector 的 reserve 方法允许在容器创建时预先分配足够的内存来存储指定数量的元素。在 vector_push_back_reserve 函数中，通过调用 str_vec.reserve(SIZE)，预先分配了足够存储 SIZE 个 std::string 元素的内存空间。 减少内存分配和复制：由于预先分配了足够的内存，后续调用 push_back 方法时，不需要再进行动态内存分配和元素复制操作。所有元素都可以直接插入到预先分配的内存空间中，从而避免了多次内存分配和复制的开销，显著提高了插入操作的效率。 性能对比 时间复杂度：vector_push_back_one_by_one 的时间复杂度为 O(nlogn)，因为每次重新分配内存时，都需要复制已有的元素，而复制操作的时间复杂度与当前元素数量成正比。相比之下，vector_push_back_reserve 的时间复杂度为 O(n)，因为所有元素都可以直接插入到预先分配的内存空间中，无需额外的复制操作。 实际性能：在实际运行中，vector_push_back_reserve 函数的执行时间通常比 vector_push_back_one_by_one 函数短得多，尤其是在插入大量元素时。这是因为 vector_push_back_one_by_one 函数需要进行多次内存分配和复制操作，而 vector_push_back_reserve 函数只需要一次内存分配，后续的插入操作非常高效。 unordered_map 替换 map 问题 问题来自与 cmu 15-445 fall 2022 p1，当时在线测试HardTest_4 超时（上限是 10s，当时程序耗时 14s）。 调优 在 macbook 上跑的项目，没有 perf 分析工具，使用 macos 中的 Instruments 进行分析。 可以看到 HardTest_4 的主要耗时在 HistoryCmpLess() 函数上： 耗时集中在下面三行代码，推测是 history_ 的随机取数据导致性能低下。 查看 history_ 类型，果然是 map 类型，但是使用 unordered_map 更加高效。更换数据类型后，耗时下降到 7s，符合预期。","categories":[{"name":"PL","slug":"PL","permalink":"https://dragonliu2018.github.io/categories/PL/"},{"name":"C++","slug":"PL/C","permalink":"https://dragonliu2018.github.io/categories/PL/C/"}],"tags":[]},{"title":"[Tool] docker 使用技巧汇总","slug":"Tool-docker-使用技巧汇总","date":"2025-09-25T11:56:32.000Z","updated":"2025-09-25T16:01:36.310Z","comments":true,"path":"2025/09/25/Tool-docker-使用技巧汇总/","permalink":"https://dragonliu2018.github.io/2025/09/25/Tool-docker-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB/","excerpt":"","text":"导出导入镜像 # 导出镜像docker save -o doris.tar apache/doris:build-env-ldb-toolchain-latest# 导入镜像docker load -i doris.tar","categories":[{"name":"Tool","slug":"Tool","permalink":"https://dragonliu2018.github.io/categories/Tool/"},{"name":"docker","slug":"Tool/docker","permalink":"https://dragonliu2018.github.io/categories/Tool/docker/"}],"tags":[]},{"title":"[PL][Python] 编程技巧汇总","slug":"PL-Python-编程技巧汇总","date":"2025-09-24T15:47:34.000Z","updated":"2025-09-24T15:48:11.695Z","comments":true,"path":"2025/09/24/PL-Python-编程技巧汇总/","permalink":"https://dragonliu2018.github.io/2025/09/24/PL-Python-%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB/","excerpt":"","text":"","categories":[{"name":"PL","slug":"PL","permalink":"https://dragonliu2018.github.io/categories/PL/"},{"name":"Python","slug":"PL/Python","permalink":"https://dragonliu2018.github.io/categories/PL/Python/"}],"tags":[]},{"title":"[PL][Python] 常见 bug 汇总","slug":"PL-Python-常见-bug-汇总","date":"2025-09-24T15:47:16.000Z","updated":"2025-09-24T15:51:51.209Z","comments":true,"path":"2025/09/24/PL-Python-常见-bug-汇总/","permalink":"https://dragonliu2018.github.io/2025/09/24/PL-Python-%E5%B8%B8%E8%A7%81-bug-%E6%B1%87%E6%80%BB/","excerpt":"","text":"sort() &amp; sorted() 对比两个列表是否含有相同的元素，不需要顺序一样。sort() 函数返回 None，因此不能直接使用 method-1 进行判断。 # method-1 errorif l1.sort() == l2.sort(): xxx# method-2 OKif sorted(l1) == sorted(l2): xxx","categories":[{"name":"PL","slug":"PL","permalink":"https://dragonliu2018.github.io/categories/PL/"},{"name":"Python","slug":"PL/Python","permalink":"https://dragonliu2018.github.io/categories/PL/Python/"}],"tags":[]},{"title":"[Tool] github 使用技巧汇总","slug":"Tool-github-使用技巧汇总","date":"2025-09-24T14:45:16.000Z","updated":"2025-09-24T15:43:04.789Z","comments":true,"path":"2025/09/24/Tool-github-使用技巧汇总/","permalink":"https://dragonliu2018.github.io/2025/09/24/Tool-github-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB/","excerpt":"","text":"新增 SSH 密钥到 GitHub 帐户 生成 key，一路默认即可： ➜ .ssh ssh-keygen 复制 id_rsa.pub 文件中的内容到 GitHub： ➜ .ssh cat id_rsa.pub 测试是否配置成功： ➜ .ssh ssh -T git@github.comHi Dragonliu2018! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.","categories":[{"name":"Tool","slug":"Tool","permalink":"https://dragonliu2018.github.io/categories/Tool/"},{"name":"git","slug":"Tool/git","permalink":"https://dragonliu2018.github.io/categories/Tool/git/"}],"tags":[]},{"title":"[Tool] git 报错汇总","slug":"Tool-git-报错汇总","date":"2025-09-24T14:44:11.000Z","updated":"2025-09-24T15:43:06.611Z","comments":true,"path":"2025/09/24/Tool-git-报错汇总/","permalink":"https://dragonliu2018.github.io/2025/09/24/Tool-git-%E6%8A%A5%E9%94%99%E6%B1%87%E6%80%BB/","excerpt":"","text":"","categories":[{"name":"Tool","slug":"Tool","permalink":"https://dragonliu2018.github.io/categories/Tool/"},{"name":"git","slug":"Tool/git","permalink":"https://dragonliu2018.github.io/categories/Tool/git/"}],"tags":[]},{"title":"[Tool] git 使用技巧汇总","slug":"Tool-git-使用技巧汇总","date":"2025-09-24T14:21:50.000Z","updated":"2025-09-25T16:01:36.310Z","comments":true,"path":"2025/09/24/Tool-git-使用技巧汇总/","permalink":"https://dragonliu2018.github.io/2025/09/24/Tool-git-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB/","excerpt":"","text":"将当前修改压到 HEAD commit git commit --amend 取消某个文件的更改 git checkout -- &lt;file_name&gt; 参考：https://blog.csdn.net/qq_32907195/article/details/115333898 删除某个文件(夹) # 推荐git rm &lt;file_name&gt;# 相当于rm &lt;file_name&gt;git add &lt;file_name&gt; ignore 已经 push 到远端的文件 【问题】 .vscode 文件夹已经 push 到远程，如何 ignore？ 【解决】 从 Git 索引中移除 .vscode 目录（不会删除本地文件夹，只是让 git 不再跟踪它）： ➜ SG-DQA git:(main) git rm -r --cached .vscoderm &#x27;.vscode/launch.json&#x27;rm &#x27;.vscode/settings.json&#x27; 添加 .gitignore 文件 .vscode/ git add &amp; git commit &amp; git push 合并多个 commit # method-1git rebase -i origin/main# method-2git rebase -i ce75153a87# method-3: 与要合并的commit数量一致git rebase -i HEAD~8 patch git diff &gt; xx.patchgit apply x.patch 本地分支 &amp; 远程分支 # 查看本地分支关联（跟踪）的远程分支之间的对应关系git branch -vv# 推送当前分支到远程（没有对应分支）git push -f --set-upstream origin dragonliu/dictionary_mysql_opt# 设置本地分支与远程分支的关联git branch --set-upstream-to=origin/&lt;远程分支名&gt; 删除分支 # 删除本地分支git branch -D fix/authentication# 删除远程分支 git push origin --delete fix/authentication 撤销 commit # 撤销本地 commitgit reset --soft HEAD^# 撤销远程 commitgit reset HEAD^git push -f 修改远程仓库链接 git remote set-url origin git@github.com:Dragonliu2018/doris.git","categories":[{"name":"Tool","slug":"Tool","permalink":"https://dragonliu2018.github.io/categories/Tool/"},{"name":"git","slug":"Tool/git","permalink":"https://dragonliu2018.github.io/categories/Tool/git/"}],"tags":[]},{"title":"[Tool] wsl 报错汇总","slug":"Tool-wsl-报错汇总","date":"2025-09-24T14:08:37.000Z","updated":"2025-09-24T14:12:11.127Z","comments":true,"path":"2025/09/24/Tool-wsl-报错汇总/","permalink":"https://dragonliu2018.github.io/2025/09/24/Tool-wsl-%E6%8A%A5%E9%94%99%E6%B1%87%E6%80%BB/","excerpt":"","text":"执行 systemctl 失败 【问题】 System has not been booted with systemd as init system (PID 1). Can&#x27;t operate. Failed to connect to bus: Host is down 【解决】 https://github.com/microsoft/WSL/issues/8883","categories":[{"name":"Tool","slug":"Tool","permalink":"https://dragonliu2018.github.io/categories/Tool/"},{"name":"wsl","slug":"Tool/wsl","permalink":"https://dragonliu2018.github.io/categories/Tool/wsl/"}],"tags":[]},{"title":"[databend] pivot 支持 subquery","slug":"databend-pivot-支持-subquery","date":"2025-09-14T09:45:42.000Z","updated":"2025-09-23T01:06:58.364Z","comments":true,"path":"2025/09/14/databend-pivot-支持-subquery/","permalink":"https://dragonliu2018.github.io/2025/09/14/databend-pivot-%E6%94%AF%E6%8C%81-subquery/","excerpt":"","text":"1 任务背景 Issue：https://github.com/databendlabs/databend/issues/16556 PR：https://github.com/databendlabs/databend/pull/16631 1.1 任务介绍 目前 databend 中的 pivot 和 unpivot 不支持 FROM/IN + subquery。→ 文档链接 要求实现类似于 snowflake 的语法，也就是让 pivot 支持 FROM/IN + subquery，unpivot 支持 FROM + subquery。→ 文档链接 databend PIVOT 语法 SELECT ...FROM ... PIVOT ( &lt;aggregate_function&gt; ( &lt;pivot_column&gt; ) FOR &lt;value_column&gt; IN ( &lt;pivot_value_1&gt; [ , &lt;pivot_value_2&gt; ... ] ) )[ ... ] &lt;aggregate_function&gt;：用于组合来自pivot_column的分组值的聚合函数。 &lt;pivot_column&gt;：将使用指定的&lt;aggregate_function&gt;进行聚合的列。 &lt;value_column&gt;：其唯一值将在旋转结果集中成为新列的列。 &lt;pivot_value_N&gt;：来自&lt;value_column&gt;的唯一值，将在旋转结果集中成为新列。 databend UNPIVOT 语法 SELECT ...FROM ... UNPIVOT ( &lt;value_column&gt; FOR &lt;name_column&gt; IN ( &lt;column_list&gt; ) )[ ... ] &lt;value_column&gt;：将存储从 &lt;column_list&gt; 中列出的列中提取的值的列。 &lt;name_column&gt;：将存储从中提取值的列的名称的列。 &lt;column_list&gt;：要取消透视的列的列表，用逗号分隔。 snowflake PIVOT 语法 123456789101112SELECT ...FROM ... PIVOT ( &lt;aggregate_function&gt; ( &lt;pivot_column&gt; ) FOR &lt;value_column&gt; IN ( &lt;pivot_value_1&gt; [ , &lt;pivot_value_2&gt; ... ] | ANY [ ORDER BY ... ] | &lt;subquery&gt; ) [ DEFAULT ON NULL (&lt;value&gt;) ] )[ ... ] snowflake UNPIVOT 语法 SELECT ...FROM ... UNPIVOT [ &#123; INCLUDE | EXCLUDE &#125; NULLS ] ( &lt;value_column&gt; FOR &lt;name_column&gt; IN ( &lt;column_list&gt; ) )[ ... ] 1.2 介绍 pivot &amp; unpivot 1.2.1 pivot（透视，一列中的属性值转成多个对应属性） https://docs.databend.com/sql/sql-commands/query-syntax/query-pivot PIVOT操作通过旋转表格并基于指定列聚合结果来转换表格，这是一个对于总结和分析大量数据以更可读格式显示非常有用的操作。 databend PIVOT 语法 SELECT ...FROM ... PIVOT ( &lt;aggregate_function&gt; ( &lt;pivot_column&gt; ) FOR &lt;value_column&gt; IN ( &lt;pivot_value_1&gt; [ , &lt;pivot_value_2&gt; ... ] ) )[ ... ] &lt;aggregate_function&gt;：用于组合来自pivot_column的分组值的聚合函数。 &lt;pivot_column&gt;：将使用指定的&lt;aggregate_function&gt;进行聚合的列。 &lt;value_column&gt;：其唯一值将在旋转结果集中成为新列的列。 &lt;pivot_value_N&gt;：来自&lt;value_column&gt;的唯一值，将在旋转结果集中成为新列。 假设我们有一个名为 monthly_sales 的表，其中包含不同员工在不同月份的销售数据。我们可以使用PIVOT操作来总结数据并计算每个员工在每个月的总销售额。 创建和插入数据 12345678910111213141516171819202122232425-- 创建monthly_sales表CREATE TABLE monthly_sales( empid INT, amount INT, month VARCHAR);-- 插入销售数据INSERT INTO monthly_sales VALUES (1, 10000, &#x27;JAN&#x27;), (1, 400, &#x27;JAN&#x27;), (2, 4500, &#x27;JAN&#x27;), (2, 35000, &#x27;JAN&#x27;), (1, 5000, &#x27;FEB&#x27;), (1, 3000, &#x27;FEB&#x27;), (2, 200, &#x27;FEB&#x27;), (2, 90500, &#x27;FEB&#x27;), (1, 6000, &#x27;MAR&#x27;), (1, 5000, &#x27;MAR&#x27;), (2, 2500, &#x27;MAR&#x27;), (2, 9500, &#x27;MAR&#x27;), (1, 8000, &#x27;APR&#x27;), (1, 10000, &#x27;APR&#x27;), (2, 800, &#x27;APR&#x27;), (2, 4500, &#x27;APR&#x27;); 使用 PIVOT 现在，我们可以使用PIVOT操作来计算每个员工在每个月的总销售额。我们将使用SUM聚合函数来计算总销售额，MONTH 列将被旋转以为每个月创建新列。 SELECT *FROM monthly_salesPIVOT(SUM(amount) FOR MONTH IN (&#x27;JAN&#x27;, &#x27;FEB&#x27;, &#x27;MAR&#x27;, &#x27;APR&#x27;))ORDER BY EMPID; 输出： +-------+-------+-------+-------+-------+| empid | jan | feb | mar | apr |+-------+-------+-------+-------+-------+| 1 | 10400 | 8000 | 11000 | 18000 || 2 | 39500 | 90700 | 12000 | 5300 |+-------+-------+-------+-------+-------+ 1.2.2 unpivot（取消透视，多个属性转成一列中对应的属性值） https://docs.databend.com/sql/sql-commands/query-syntax/query-unpivot UNPIVOT 操作通过将列转换为行来旋转表。它是一个关系操作符，接受两列（来自表或子查询），以及列的列表，并为列表中指定的每列生成一行。在查询中，它在 FROM 子句中指定，位于表名或子查询之后。 databend UNPIVOT 语法 SELECT ...FROM ... UNPIVOT ( &lt;value_column&gt; FOR &lt;name_column&gt; IN ( &lt;column_list&gt; ) )[ ... ] &lt;value_column&gt;：将存储从 &lt;column_list&gt; 中列出的列中提取的值的列。 &lt;name_column&gt;：将存储从中提取值的列的名称的列。 &lt;column_list&gt;：要取消透视的列的列表，用逗号分隔。 让我们取消透视个别月份列，以返回每位员工每月的单一销售值： 创建和插入数据 12345678910111213-- 创建 unpivoted_monthly_sales 表CREATE TABLE unpivoted_monthly_sales( empid INT, jan INT, feb INT, mar INT, apr INT);-- 插入销售数据INSERT INTO unpivoted_monthly_sales VALUES (1, 10400, 8000, 11000, 18000), (2, 39500, 90700, 12000, 5300); 使用 UNPIVOT SELECT *FROM unpivoted_monthly_sales UNPIVOT (amount FOR month IN (jan, feb, mar, apr)); 输出： 123456789101112+-------+-------+--------+| empid | month | amount |+-------+-------+--------+| 1 | jan | 10400 || 1 | feb | 8000 || 1 | mar | 11000 || 1 | apr | 18000 || 2 | jan | 39500 || 2 | feb | 90700 || 2 | mar | 12000 || 2 | apr | 5300 |+-------+-------+--------+ 2 设计参考（竞品分析） 3 思路与实现 3.1 思路 实现 from + subquery 较为简单，在 TableReference::Subquery 加上 pivot 和 unpivot 字段，修改 parser 及其他相关地方。 123456789101112let subquery = map( rule! &#123; LATERAL? ~ &quot;(&quot; ~ #query ~ &quot;)&quot; ~ #table_alias? ~ #pivot? ~ #unpivot? &#125;, |(lateral, _, subquery, _, alias, pivot, unpivot)| TableReferenceElement::Subquery &#123; lateral: lateral.is_some(), subquery: Box::new(subquery), alias, pivot: pivot.map(Box::new), unpivot: unpivot.map(Box::new), &#125;,); 实现 in + subquery 相对复杂，因为在 binder 的时候必须知道 column 的 name 才能生成逻辑计划，所以只能先执行一下这个 subquery ，然后把返回值当作 values 处理；但是执行 query/plan 是在 service 模块下，binder 是在 sql 模块，存在循环调用的问题。→ 解决循环依赖问题 解决思路有三种： 【思路-1】在 pivot_rewrite 阶段（binder）执行 Subquery 得到答案，参考 QuerySampleExecutor 写个回调函数在 binder 里面调一下 service 的函数执行。 Pivot 结构体新添 Subquery 字段（Query），用于存储 in + subquery 中的 subquery； Pivot 123456789101112131415161718// 原版pub struct Pivot &#123; pub aggregate: Expr, pub value_column: Identifier, pub values: Vec&lt;Expr&gt;,&#125;// 修改后pub enum PivotValues &#123; ColumnValues(Vec&lt;Expr&gt;), Subquery(Box&lt;Query&gt;),&#125;pub struct Pivot &#123; pub aggregate: Expr, pub value_column: Identifier, pub values: PivotValues,&#125; 在 rewrite_pivot 函数中对 Subquery 进行 parser + rewrite + opt + exec 等操作，并将结果存在原来的 values 字段，后续操作一致。 执行 query 的回调函数目前有基于 PhysicalPlan 的，一种方案是基于该函数进行操作；另一种方案是新添基于 Query String 执行的回调函数。 【思路-2】在发现 subquery 的时候返回，在 service 里面执行之后重写 sql，然后再次执行。 【思路-3】现在的 plan_sql 函数里面会执行 parser 并生成 plan，可以把这个函数拆成两个： 第一个函数执行 parser，生成 stmt，同时进行一些 rewrite，如果这时发现有 subquery 的话，就先执行一下，然后 rewrite。 第二个函数传入 rewrite 之后的 stmt，生成 plan。 本着尽可能少的改动当前代码结构的原则，选择**【思路-1】**进行实现。 3.2 review 相关修改 【review-1】避免不必要的 clone 123456789101112131415161718192021// 原版let value = columns[0].to_column(block.num_rows()); // 修改for row in 0..block.num_rows() &#123; match columns[0].value.index(row).unwrap() &#123; ScalarRef::String(s) =&gt; &#123; let literal = Expr::Literal &#123; span, value: Literal::String(s.to_string()), &#125;; values.push(literal); &#125; _ =&gt; &#123; return Err(ErrorCode::SemanticError( &quot;The subquery of `pivot in` must return a string type&quot;, ) .set_span(span)); &#125; &#125;&#125; 【review-2】针对于 subquery 返回的每个 String 不需要设置 span，使用 subquery 的 span 即可。 【review-3】使用 block.num_columns() 计算 column 的数量。 // 原版let columns = block.columns();if columns.len() != 1 &#123; // ...&#125;// 修改后if block.num_columns() != 1 &#123; // ...&#125; 【review-4】将 sample_executor 和 subquery_executor 合并成一个 query_executor，实现不同的函数用来做区分。 【review-5】对返回的 ErrorCode 设置 span。→ span 不使用 span： return Err(ErrorCode::SemanticError( &quot;The subquery of `pivot in` must return one column&quot;,)); MySQL [dev]&gt; SELECT * FROM (select * from monthly_sales) PIVOT(SUM(amount) FOR MONTH IN (select distinct month, month from monthly_sales)) ORDER BY EMPID;ERROR 1105 (HY000): SemanticError. Code: 1065, Text = The subquery of `pivot in` must return one column. 使用 span： return Err(ErrorCode::SemanticError( &quot;The subquery of `pivot in` must return one column&quot;,).set_span(span)); MySQL [dev]&gt; SELECT * FROM (select * from monthly_sales) PIVOT(SUM(amount) FOR MONTH IN (select distinct empid from monthly_sales)) ORDER BY EMPID;ERROR 1105 (HY000): SemanticError. Code: 1065, Text = error: --&gt; SQL:1:78 |1 | SELECT * FROM (select * from monthly_sales) PIVOT(SUM(amount) FOR MONTH IN (select distinct empid from monthly_sales)) ORDER BY EMPID | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ The subquery of `pivot in` must return a string type. 3.3 bugs 【bug-1】因为需要两次用到 pivot 变量，所以会报 error: use of moved value 的错误。→ error: use of moved value 把 pivot 和 unpivot 挪出去，改成两个单独的函数。 【bug-2】rewrite_pivot 是非 async 函数，但是 subquery_executor.execute_query_with_sql_string 是 async 函数，rewrite_pivot 中需要调用 subquery_executor.execute_query_with_sql_string。所以会报错：await is only allowed inside async functions and blocks。→ 在非 async 函数里调用 async 函数 databend_common_base::runtime::block_on 4 测试 4.1 功能测试 与 snowflake 语法保持一致： pivot 支持三种 subquery，from + subquery、in + subquery、from + subquery + in + subquery。 unpivot 只支持 from + subquery 一种。 4.1.1 手动测试 测试 Pivot Create the monthly_sales table CREATE TABLE monthly_sales( empid INT, amount INT, month VARCHAR); Insert sales data 1234567891011121314151617INSERT INTO monthly_sales VALUES (1, 10000, &#x27;JAN&#x27;), (1, 400, &#x27;JAN&#x27;), (2, 4500, &#x27;JAN&#x27;), (2, 35000, &#x27;JAN&#x27;), (1, 5000, &#x27;FEB&#x27;), (1, 3000, &#x27;FEB&#x27;), (2, 200, &#x27;FEB&#x27;), (2, 90500, &#x27;FEB&#x27;), (1, 6000, &#x27;MAR&#x27;), (1, 5000, &#x27;MAR&#x27;), (2, 2500, &#x27;MAR&#x27;), (2, 9500, &#x27;MAR&#x27;), (1, 8000, &#x27;APR&#x27;), (1, 10000, &#x27;APR&#x27;), (2, 800, &#x27;APR&#x27;), (2, 4500, &#x27;APR&#x27;); Pivot（原版） SELECT * FROM monthly_salesPIVOT(SUM(amount) FOR MONTH IN (&#x27;JAN&#x27;, &#x27;FEB&#x27;, &#x27;MAR&#x27;, &#x27;APR&#x27;))ORDER BY EMPID; from + subquery SELECT *FROM (select * from monthly_sales)PIVOT(SUM(amount) FOR MONTH IN (&#x27;JAN&#x27;, &#x27;FEB&#x27;, &#x27;MAR&#x27;, &#x27;APR&#x27;))ORDER BY EMPID; in + subquery SELECT * FROM monthly_salesPIVOT(SUM(amount) FOR MONTH IN (select distinct month from monthly_sales))ORDER BY EMPID; from + in + subquery SELECT * FROM (select * from monthly_sales)PIVOT(SUM(amount) FOR MONTH IN (select distinct month from monthly_sales))ORDER BY EMPID; Answer +-------+-------+-------+-------+-------+| empid | jan | feb | mar | apr |+-------+-------+-------+-------+-------+| 1 | 10400 | 8000 | 11000 | 18000 || 2 | 39500 | 90700 | 12000 | 5300 |+-------+-------+-------+-------+-------+ 测试 Unpivot Create the unpivoted_monthly_sales table CREATE TABLE unpivoted_monthly_sales( empid INT, jan INT, feb INT, mar INT, apr INT); Insert sales data INSERT INTO unpivoted_monthly_sales VALUES (1, 10400, 8000, 11000, 18000), (2, 39500, 90700, 12000, 5300); unpivot（原版） SELECT *FROM unpivoted_monthly_sales UNPIVOT (amount FOR month IN (jan, feb, mar, apr)); from + subquery SELECT * FROM (SELECT * FROM monthly_sales_1) UNPIVOT(sales FOR month IN (jan, feb, mar, april)) ORDER BY empid Answer 123456789101112+-------+-------+--------+| empid | month | amount |+-------+-------+--------+| 1 | jan | 10400 || 1 | feb | 8000 || 1 | mar | 11000 || 1 | apr | 18000 || 2 | jan | 39500 || 2 | feb | 90700 || 2 | mar | 12000 || 2 | apr | 5300 |+-------+-------+--------+ 4.1.2 单元测试（ast 相关） make unit-test parser 改了会导致之前的测试失败，修复下面两个文件： src/query/ast/tests/it/testdata/stmt.txt src/query/ast/tests/it/testdata/query.txt 另外在 test_query 函数加上一个 pivot &amp; unpivot 带 subquery 的测试用例，相关文件：src/query/ast/tests/it/parser.rs。 4.1.3 逻辑测试（sql 执行结果） make sqllogic-test 为了加快测试速度，可以指定目录进行执行，甚至可以修改文件名使其在当前目录先执行： ./target/debug/databend-sqllogictests --handlers mysql --run_dir query 添加 pivot &amp; unpivot 相关 sql 查询，相关文件： tests/sqllogictests/suites/query/pivot.test tests/sqllogictests/suites/query/unpivot.test 4.2 性能测试 5 难点 6 TODO X 参考 https://docs.snowflake.com/en/sql-reference/constructs/pivot https://docs.snowflake.com/en/sql-reference/constructs/unpivot https://docs.databend.com/sql/sql-commands/query-syntax/query-pivot https://docs.databend.com/sql/sql-commands/query-syntax/query-unpivot","categories":[{"name":"DB","slug":"DB","permalink":"https://dragonliu2018.github.io/categories/DB/"},{"name":"databend","slug":"DB/databend","permalink":"https://dragonliu2018.github.io/categories/DB/databend/"},{"name":"函数/表达式","slug":"DB/函数-表达式","permalink":"https://dragonliu2018.github.io/categories/DB/%E5%87%BD%E6%95%B0-%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}],"tags":[{"name":"pr","slug":"pr","permalink":"https://dragonliu2018.github.io/tags/pr/"}]},{"title":"[doris][Status] Implement format methods for Status","slug":"doris-Status-Implement-format-methods-for-Status","date":"2025-09-14T09:26:44.000Z","updated":"2025-09-23T01:05:52.936Z","comments":true,"path":"2025/09/14/doris-Status-Implement-format-methods-for-Status/","permalink":"https://dragonliu2018.github.io/2025/09/14/doris-Status-Implement-format-methods-for-Status/","excerpt":"","text":"1 issue 介绍 当前 Status 类型进行 format 时，需要调用 to_string 函数： fmt::format(&quot;&#123;&#125;&quot;, status.to_string()); 想要的效果是只需要传入 Status 类型即可： fmt::format(&quot;&#123;&#125;&quot;, status); 2 实现 2.1 解析 fmt 库提供了一个类模板 fmt::formatter，通过模板特化为 Status 类型提供适当的格式化方式。 然后实现 parse 和 format 函数即可： parse 函数负责解析格式字符串。在通常情况下，用户可能不需要提供自己的 parse 函数，而可以使用 fmt 默认提供的版本，该版本简单地返回解析上下文的开始迭代器。 format 函数是用户必须提供的关键成员函数。它定义了如何将自定义类型格式化为字符串。 2.2 功能代码 👉 **参考：**https://wgml.pl/blog/formatting-user-defined-types-fmt.html 12345678910111213// specify formatter for Statustemplate &lt;&gt;struct fmt::formatter&lt;doris::Status&gt; &#123; template &lt;typename ParseContext&gt; constexpr auto parse(ParseContext&amp; ctx) &#123; return ctx.begin(); &#125; template &lt;typename FormatContext&gt; auto format(doris::Status const&amp; status, FormatContext&amp; ctx) &#123; return fmt::format_to(ctx.out(), &quot;&#123;&#125;&quot;, status.to_string()); &#125;&#125;; 2.3 测试代码 实现完成后，编写测试样例，这里需要注意覆盖率。 reviewer 提出的建议是： please add 3 tests：1. status == ok2. status == error &amp;&amp; has stacktrace3. status == error &amp;&amp; do not have stacktrace 3 问题 3.1 ld: symbol(s) not found for architecture x86_64 在本地 macos 上尝试写了个测试程序，但是发生下面的报错： ➜ test-reset git:(main) ✗ g++ test.cpp -std=c++20 -o testUndefined symbols for architecture x86_64: &quot;void fmt::v10::detail::vformat_to&lt;char&gt;(fmt::v10::detail::buffer&lt;char&gt;&amp;, fmt::v10::basic_string_view&lt;char&gt;, fmt::v10::detail::vformat_args&lt;char&gt;::type, fmt::v10::detail::locale_ref)&quot;, referenced from: fmt::v10::appender fmt::v10::vformat_to&lt;fmt::v10::appender, 0&gt;(fmt::v10::appender, fmt::v10::basic_string_view&lt;char&gt;, fmt::v10::basic_format_args&lt;fmt::v10::basic_format_context&lt;fmt::v10::appender, char&gt; &gt;) in test-878b3f.o &quot;fmt::v10::detail::assert_fail(char const*, int, char const*)&quot;, referenced from: std::__1::make_unsigned&lt;long&gt;::type fmt::v10::detail::to_unsigned&lt;long&gt;(long) in test-878b3f.o &quot;fmt::v10::vprint(fmt::v10::basic_string_view&lt;char&gt;, fmt::v10::basic_format_args&lt;fmt::v10::basic_format_context&lt;fmt::v10::appender, char&gt; &gt;)&quot;, referenced from: _main in test-878b3f.old: symbol(s) not found for architecture x86_64clang: error: linker command failed with exit code 1 (use -v to see invocation) 解决：原因是未链接 fmt 库文件 g++ test.cpp -std=c++20 -o test -lfmt 参考：https://stackoverflow.com/questions/56608684/how-to-use-the-fmt-library-without-getting-undefined-symbols-for-architecture-x 3.2 fmt::formatter 模板特化代码不能在 doris 的 namespace 开始将特化代码放在了 doris namespace 中，发生了下面的报错： Class template specialization of &#x27;formatter&#x27; not in a namespace enclosing &#x27;v8&#x27; is a Microsoft extension clang(-Wmicrosoft-template)[core.h(707, 8): ] Explicitly specialized declaration is here 解决： namespace doris &#123;// doris code&#125; // end doris_namespace// define formatter here **参考：**https://github.com/fmtlib/fmt/issues/2767","categories":[{"name":"DB","slug":"DB","permalink":"https://dragonliu2018.github.io/categories/DB/"},{"name":"doris","slug":"DB/doris","permalink":"https://dragonliu2018.github.io/categories/DB/doris/"}],"tags":[{"name":"pr","slug":"pr","permalink":"https://dragonliu2018.github.io/tags/pr/"}]},{"title":"[Tool] Hexo 使用教程","slug":"Tool-Hexo-使用教程","date":"2025-09-13T15:37:08.000Z","updated":"2025-09-23T01:03:51.746Z","comments":true,"path":"2025/09/13/Tool-Hexo-使用教程/","permalink":"https://dragonliu2018.github.io/2025/09/13/Tool-Hexo-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","excerpt":"","text":"环境准备 ➜ nvm --version0.39.1➜ node -vv24.8.0➜ npm -v11.6.0# 安装 Hexonpm install -g hexo-cli 本地运行 Hexo 初始化 hexo，生成 hexo-blog 目录 hexo init hexo-blog 进入 hexo-blog 目录，下载 pure 主题和 source 文章 cd hexo-bloggit clone https://github.com/Dragonliu2018/hexo-theme-pure.git themes/pure# 删除默认生成的 _posts 目录rm -rf source/_postsgit clone https://github.com/Dragonliu2018/hexo-source.git source 配置 pure，ref link npm install hexo-wordcount --savenpm install hexo-generator-json-content --savenpm install hexo-generator-feed --savenpm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --savenpm install hexo-neat --savenpm install hexo-translate-title --savenpm un hexo-renderer-marked --savenpm i hexo-renderer-markdown-it-plus --savenpm install hexo-deployer-git --save 修改 _config.yml 1234567891011121314151617# 页面中分类等导航词的语言- language: en+ language: zh-CN# 搜索界面的分类部分拼接 url- url: http://example.com+ url: https://dragonliu2018.github.io# 设置主题- theme: landscape+ theme: pure# 设置部署deploy: type: git repo: https://github.com/dragonliu2018/dragonliu2018.github.io.git branch: master 运行 hexo hexo ghexo s 部署 Github 参考：https://hexo.io/docs/one-command-deployment 安装 hexo-deployer-git npm install hexo-deployer-git --save 修改项目根目录 blog 下的 _config.yml deploy: type: git repo: https://github.com/dragonliu2018/dragonliu2018.github.io.git branch: master 部署 hexo g 常用命令 hexo cleanhexo ghexo shexo d","categories":[{"name":"Tool","slug":"Tool","permalink":"https://dragonliu2018.github.io/categories/Tool/"},{"name":"Hexo","slug":"Tool/Hexo","permalink":"https://dragonliu2018.github.io/categories/Tool/Hexo/"}],"tags":[]}],"categories":[{"name":"PL","slug":"PL","permalink":"https://dragonliu2018.github.io/categories/PL/"},{"name":"C++","slug":"PL/C","permalink":"https://dragonliu2018.github.io/categories/PL/C/"},{"name":"Tool","slug":"Tool","permalink":"https://dragonliu2018.github.io/categories/Tool/"},{"name":"docker","slug":"Tool/docker","permalink":"https://dragonliu2018.github.io/categories/Tool/docker/"},{"name":"Python","slug":"PL/Python","permalink":"https://dragonliu2018.github.io/categories/PL/Python/"},{"name":"git","slug":"Tool/git","permalink":"https://dragonliu2018.github.io/categories/Tool/git/"},{"name":"wsl","slug":"Tool/wsl","permalink":"https://dragonliu2018.github.io/categories/Tool/wsl/"},{"name":"DB","slug":"DB","permalink":"https://dragonliu2018.github.io/categories/DB/"},{"name":"databend","slug":"DB/databend","permalink":"https://dragonliu2018.github.io/categories/DB/databend/"},{"name":"函数/表达式","slug":"DB/函数-表达式","permalink":"https://dragonliu2018.github.io/categories/DB/%E5%87%BD%E6%95%B0-%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"doris","slug":"DB/doris","permalink":"https://dragonliu2018.github.io/categories/DB/doris/"},{"name":"Hexo","slug":"Tool/Hexo","permalink":"https://dragonliu2018.github.io/categories/Tool/Hexo/"}],"tags":[{"name":"pr","slug":"pr","permalink":"https://dragonliu2018.github.io/tags/pr/"}]}